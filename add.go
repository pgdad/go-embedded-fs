package main

import (
	"fmt"
	"mime"
	"os"
	"path/filepath"
	"strings"
)

// AddFiles reads files, encrypts them, and updates the embedded.go source file
func AddFiles(filePaths []string, key []byte) error {
	files := make(map[string]EmbeddedFile)

	// Process each file
	for _, filePath := range filePaths {
		data, err := os.ReadFile(filePath)
		if err != nil {
			return fmt.Errorf("failed to read file %s: %w", filePath, err)
		}

		encrypted, err := Encrypt(data, key)
		if err != nil {
			return fmt.Errorf("failed to encrypt file %s: %w", filePath, err)
		}

		// Get filename and content type
		fileName := filepath.Base(filePath)
		contentType := getContentType(fileName)

		files[fileName] = EmbeddedFile{
			Name:          fileName,
			EncryptedData: encrypted,
			ContentType:   contentType,
		}

		fmt.Printf("Added: %s (%s)\n", fileName, contentType)
	}

	// Update the embedded.go file
	if err := updateEmbeddedFile(files); err != nil {
		return fmt.Errorf("failed to update embedded.go: %w", err)
	}

	fmt.Printf("\nSuccessfully embedded %d file(s) in source code.\n", len(files))
	fmt.Println("Run 'go build' to rebuild the binary with the new files.")

	return nil
}

// getContentType determines the MIME type based on file extension
func getContentType(fileName string) string {
	ext := filepath.Ext(fileName)
	contentType := mime.TypeByExtension(ext)
	if contentType == "" {
		contentType = "application/octet-stream"
	}
	return contentType
}

// updateEmbeddedFile rewrites the embedded.go file with new encrypted data
func updateEmbeddedFile(files map[string]EmbeddedFile) error {
	var builder strings.Builder

	builder.WriteString("package main\n\n")
	builder.WriteString("// EmbeddedFile represents an encrypted file embedded in the binary\n")
	builder.WriteString("type EmbeddedFile struct {\n")
	builder.WriteString("\tName            string\n")
	builder.WriteString("\tEncryptedData   string\n")
	builder.WriteString("\tContentType     string\n")
	builder.WriteString("}\n\n")
	builder.WriteString("// EmbeddedFiles contains all encrypted files\n")
	builder.WriteString("// This map will be automatically generated by the 'add' command\n")
	builder.WriteString("var EmbeddedFiles = map[string]EmbeddedFile{\n")

	for name, file := range files {
		builder.WriteString(fmt.Sprintf("\t%q: {\n", name))
		builder.WriteString(fmt.Sprintf("\t\tName:          %q,\n", file.Name))
		builder.WriteString(fmt.Sprintf("\t\tEncryptedData: %q,\n", file.EncryptedData))
		builder.WriteString(fmt.Sprintf("\t\tContentType:   %q,\n", file.ContentType))
		builder.WriteString("\t},\n")
	}

	builder.WriteString("}\n")

	// Write the new file
	if err := os.WriteFile("embedded.go", []byte(builder.String()), 0644); err != nil {
		return err
	}

	return nil
}
